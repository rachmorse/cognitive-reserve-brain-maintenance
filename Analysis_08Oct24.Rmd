---
title: "Analysis"
output: html_document
date: "2024-04-30"
---
```{r setup, include=FALSE}
if (!require("ggplot2")) {
  install.packages("ggplot2")
  require("ggplot2")
}
if (!require("dplyr")) {
  install.packages("dplyr")
  require("dplyr")
}
if (!require("psych")) {
  install.packages("psych")
  require("psych")
}
if (!require("stringr")) {
  install.packages("stringr")
  require("stringr")
}
if (!require("tidyr")) {
  install.packages("tidyr")
  require("tidyr")
}
if (!require("scales")) {
  install.packages("scales")
  require("scales")
}
if (!require("mgcv")) {
  install.packages("mgcv")
  require("mgcv")
}

library(readr)
library(ggsignif)
```

Start by reading in the clean data in wide format 
```{r warning=FALSE}
clean_data <- read.csv("/tsd/p274/data/durable/projects/p027-cr_bm/Clean Data All Cohorts/Wide Format/Merged cohorts analysed data wide.csv")
```

Visualize the HC and memory data
```{r warning=FALSE}
# Look at memory slopes
ggplot(clean_data, aes(x = memory_slopes)) +
  geom_histogram()

memory_normality <- shapiro.test(clean_data$memory_slopes)
print(memory_normality)

# Look at hippocampus slopes
ggplot(clean_data, aes(x = hc_slopes)) +
  geom_histogram()

hc_normality <- shapiro.test(clean_data$hc_slopes)
print(hc_normality)

# Visualize the FC data
ggplot(clean_data, aes(x = dmn_slopes)) +
  geom_histogram()

dmn_normality <- shapiro.test(clean_data$dmn_slopes)
print(dmn_normality)
```
Fit residual models to be able to use throughout
```{r}
# In order to be able to save these models, the NAs have to be removed so I made a df for each type to remove the data and then can merge back into clean_df

# Remove NAs first
fc_res_data <- clean_data %>%
  filter(!(is.na(dmn_slopes)))

hc_res_data <- clean_data %>%
  filter(!(is.na(hc_slopes)))

hc_bl_res_data <- clean_data %>%
  filter(!is.na(hc_slopes) & !is.na(edu) & !is.na(sex))

mem_res_data <- clean_data %>%
  filter(!(is.na(memory_slopes)))

mem_bl_res_data <- clean_data %>%
  filter(!is.na(memory_slopes) & !is.na(edu) & !is.na(sex))

# Fit a linear model including cohort as a covariate
residual_model_dmn <- lm(dmn_slopes ~ study, data = fc_res_data)
residual_model_ec <- lm(ec_slopes ~ study, data = fc_res_data)
residual_model_sn <- lm(sn_slopes ~ study, data = fc_res_data)
residual_model_mem <- lm(memory_slopes ~ study, data = mem_res_data)
residual_model_bl_mem <- lm(memory_baseline ~ study, data = mem_bl_res_data)
residual_model_fu_mem <- lm(memory_followup ~ study, data = mem_bl_res_data)
residual_model_hc <- lm(hc_slopes ~ study, data = hc_res_data)
residual_model_bl_hc <- lm(adj_HIP_total_baseline ~ study, data = hc_bl_res_data)
residual_model_fu_hc <- lm(adj_HIP_total_followup ~ study, data = hc_bl_res_data)
residual_model_bl_dmn <- lm(dmn_baseline ~ study, data = fc_res_data)
residual_model_fu_dmn <- lm(dmn_followup ~ study, data = fc_res_data)
residual_model_fu_dmn <- lm(dmn_followup ~ study, data = fc_res_data)
residual_model_edu <- lm(edu ~ study, data = hc_bl_res_data)


# Extract residuals
fc_res_data$res_dmn_slopes <- residuals(residual_model_dmn)
fc_res_data$res_ec_slopes <- residuals(residual_model_ec)
fc_res_data$res_sn_slopes <- residuals(residual_model_sn)
mem_res_data$res_mem_slopes <- residuals(residual_model_mem)
mem_bl_res_data$res_mem_bl <- residuals(residual_model_bl_mem)
mem_bl_res_data$res_mem_fu <- residuals(residual_model_fu_mem)
hc_res_data$res_hc_slopes <- residuals(residual_model_hc)
hc_bl_res_data$res_hc_bl <- residuals(residual_model_bl_hc)
hc_bl_res_data$res_hc_fu <- residuals(residual_model_fu_hc)
fc_res_data$res_dmn_bl <- residuals(residual_model_bl_dmn)
fc_res_data$res_dmn_fu <- residuals(residual_model_fu_dmn)
hc_bl_res_data$res_edu <- residuals(residual_model_edu)

# Filter dfs to put back in
fc_res_data <- fc_res_data %>%
  select(id, res_dmn_slopes, res_sn_slopes, res_ec_slopes, res_dmn_bl, res_dmn_fu)

hc_res_data <- hc_res_data %>%
  select(id, res_hc_slopes)

mem_bl_res_data <- mem_bl_res_data %>%
  select(id, res_mem_bl, res_mem_fu)

mem_res_data <- mem_res_data %>%
  select(id, res_mem_slopes)

hc_bl_res_data <- hc_bl_res_data %>%
  select(id, res_hc_bl, res_hc_fu, res_edu)

emhc_data <- merge(fc_res_data, hc_res_data, by = c("id"), all = TRUE)
emhc_data <- merge(emhc_data, mem_res_data, by = c("id"), all = TRUE)
emhc_data <- merge(emhc_data, hc_bl_res_data, by = c("id"), all = TRUE)
emhc_data <- merge(emhc_data, mem_bl_res_data, by = c("id"), all = TRUE)
emhc_data <- merge(clean_data, emhc_data, by = c("id"), all = TRUE)
```

Using the new formula to calculate a BM continuous variable 
```{r}
# First create a scaled version of the HC and memory annual change variables using the residuals
emhc_data <- emhc_data %>%
  mutate(
    res_hc_slopes_scaled = res_hc_slopes / abs(min(res_hc_slopes)),
    res_mem_slopes_scaled = res_mem_slopes / abs(max(res_mem_slopes))
  )

# Define the function to calculate the distance from the data point to the point (1,1)
distance_to_bm_point <- function(y, x) {
  # Calculate the shortest distance from the data point to (1,1)
  distance <- sqrt((x - 1)^2 + (y - 1)^2)

  return(distance)
}

emhc_data <- emhc_data %>%
  mutate(dist_to_bm_point = distance_to_bm_point(res_mem_slopes_scaled, res_hc_slopes_scaled))

# Define the function to calculate the distance from the data point to the point (1,1)
distance_to_bm_line <- function(y, x) {
  # Calculate the intersection point (projection of the point onto the line x = y)
  intersection_x <- (x + y) / 2
  intersection_y <- intersection_x

  # Calculate the distance from the point (x, y) to the projection point
  distance <- sqrt((intersection_x - x)^2 + (intersection_y - y)^2)

  return(distance)
}

emhc_data <- emhc_data %>%
  mutate(dist_to_bm_line = distance_to_bm_line(res_mem_slopes_scaled, res_hc_slopes_scaled))

emhc_data <- emhc_data %>%
  mutate(dist_to_double_bm = dist_to_bm_line + dist_to_bm_point)
```

Descriptive stats BM
```{r}
describe(emhc_data$dist_to_double_bm)
shapiro.test(emhc_data$dist_to_double_bm)
ggplot(emhc_data, aes(x = dist_to_double_bm)) +
  geom_histogram(fill = "lightpink", color = "black", binwidth = 0.1)
```

Now create the CR continuous variable 
```{r}
# Define the function to calculate the distance from the data point to the point (1,1)
distance_to_cr_point <- function(y, x) {
  # Calculate the shortest distance from the data point to (1,1)
  distance <- sqrt((x + 1)^2 + (y - 1)^2)

  return(distance)
}


emhc_data <- emhc_data %>%
  mutate(dist_to_cr_point = distance_to_cr_point(res_mem_slopes_scaled, res_hc_slopes_scaled))

# Define the function to calculate the distance from to the line x = -y
distance_to_cr_line <- function(y, x) {
  # Calculate the intersection point (projection of the point onto the line x = -y)
  intersection_x <- (x - y) / 2
  intersection_y <- -(intersection_x)

  # Calculate the distance from the point (x, y) to the intersection point
  distance <- sqrt((intersection_x - x)^2 + (intersection_y - y)^2)

  return(distance)
}

emhc_data <- emhc_data %>%
  mutate(dist_to_cr_line = distance_to_cr_line(res_mem_slopes_scaled, res_hc_slopes_scaled))


emhc_data <- emhc_data %>%
  mutate(dist_to_double_cr = dist_to_cr_line + dist_to_cr_point)
```


Descriptive stats CR
```{r}
describe(emhc_data$dist_to_double_cr)
shapiro.test(emhc_data$dist_to_double_cr)
ggplot(emhc_data, aes(x = dist_to_double_cr)) +
  geom_histogram(fill = "lightpink", color = "black", binwidth = 0.1)
```

This section create a df with random points to be able to visualize all of the different methods that we've used to create the CR and BM variables 

```{r}
# First create the df with random values for x and y and set the min and max to be the same as the emhc scaled data
n <- 40000
x <- runif(n, min = -1, max = 1)
y <- runif(n, min = -1, max = 1)
random_df <- data.frame(x = x, y = y)

# Recreate all the CR and BM values using the formulas already defined in the analyses above

# Calculate distance to BM point
random_df <- random_df %>%
  mutate(dist_to_bm_point = distance_to_bm_point(y, x))

# Calculate distance to CR point
random_df <- random_df %>%
  mutate(dist_to_cr_point = distance_to_cr_point(y, x))

# Calculate distance to BM line
random_df <- random_df %>%
  mutate(dist_to_bm_line = distance_to_bm_line(y, x))

# Calculate distance to CR line
random_df <- random_df %>%
  mutate(dist_to_cr_line = distance_to_cr_line(y, x))

# Calculate distance to BM line and point
random_df <- random_df %>%
  mutate(dist_to_double_bm = dist_to_bm_line + dist_to_bm_point)

# Calculate distance to CR line and point
random_df <- random_df %>%
  mutate(dist_to_double_cr = dist_to_cr_line + dist_to_cr_point)

# Plot all the new variables
custom_colors <- c("#ff595e", "#ff924c", "#ffca3a", "#c5ca30", "#8ac926", "#52a675", "#1982c4", "#4267ac", "#6a4c93", "purple")

ggplot(random_df, aes(y = y, x = x, color = (dist_to_bm_point))) +
  geom_point(size = 2) +
  scale_color_gradientn(
    colors = custom_colors,
    values = scales::rescale(c(-1, -0.77, -0.55, -0.33, -0.11, 0.11, 0.33, 0.55, 0.77, 1))
  ) +
  geom_abline(slope = 1, intercept = 0, color = "grey", size = 1) + # Line y = x
  geom_abline(slope = 0, intercept = 0, color = "grey", size = 1) +
  geom_abline(slope = 10000, intercept = 0, color = "grey", size = 1) +
  labs(
    y = "Scaled Memory Slopes",
    x = "Scaled Hippocampus Slopes",
    color = "Distance to BM point"
  ) +
  theme_minimal() +
  guides(color = guide_colorbar(reverse = TRUE))

ggplot(random_df, aes(y = y, x = x, color = (dist_to_bm_line))) +
  geom_point(size = 2) +
  scale_color_gradientn(
    colors = custom_colors,
    values = scales::rescale(c(-1, -0.77, -0.55, -0.33, -0.11, 0.11, 0.33, 0.55, 0.77, 1))
  ) +
  geom_abline(slope = 1, intercept = 0, color = "grey", size = 1) + # Line y = x
  geom_abline(slope = 0, intercept = 0, color = "grey", size = 1) +
  geom_abline(slope = 10000, intercept = 0, color = "grey", size = 1) +
  labs(
    y = "Scaled Memory Slopes",
    x = "Scaled Hippocampus Slopes",
    color = "Distance to BM line"
  ) +
  theme_minimal() +
  guides(color = guide_colorbar(reverse = TRUE))

ggplot(random_df, aes(y = y, x = x, color = (dist_to_double_bm))) +
  geom_point(size = 2) +
  scale_color_gradientn(
    colors = custom_colors,
    values = scales::rescale(c(-1, -0.77, -0.55, -0.33, -0.11, 0.11, 0.33, 0.55, 0.77, 1))
  ) +
  geom_abline(slope = 1, intercept = 0, color = "grey", size = 1) + # Line y = x
  geom_abline(slope = 0, intercept = 0, color = "grey", size = 1) +
  geom_abline(slope = 10000, intercept = 0, color = "grey", size = 1) +
  labs(
    y = "Scaled Memory Slopes",
    x = "Scaled Hippocampus Slopes",
    color = "Distance to BM point / line"
  ) +
  theme_minimal() +
  guides(color = guide_colorbar(reverse = TRUE))

ggplot(random_df, aes(y = y, x = x, color = (dist_to_cr_point))) +
  geom_point(size = 2) +
  scale_color_gradientn(
    colors = custom_colors,
    values = scales::rescale(c(-1, -0.77, -0.55, -0.33, -0.11, 0.11, 0.33, 0.55, 0.77, 1))
  ) +
  geom_abline(slope = 1, intercept = 0, color = "grey", size = 1) + # Line y = x
  geom_abline(slope = 0, intercept = 0, color = "grey", size = 1) +
  geom_abline(slope = 10000, intercept = 0, color = "grey", size = 1) +
  labs(
    y = "Scaled Memory Slopes",
    x = "Scaled Hippocampus Slopes",
    color = "Distance to CR point"
  ) +
  theme_minimal() +
  guides(color = guide_colorbar(reverse = TRUE))

ggplot(random_df, aes(y = y, x = x, color = (dist_to_cr_line))) +
  geom_point(size = 2) +
  scale_color_gradientn(
    colors = custom_colors,
    values = scales::rescale(c(-1, -0.77, -0.55, -0.33, -0.11, 0.11, 0.33, 0.55, 0.77, 1))
  ) +
  geom_abline(slope = 1, intercept = 0, color = "grey", size = 1) + # Line y = x
  geom_abline(slope = 0, intercept = 0, color = "grey", size = 1) +
  geom_abline(slope = 10000, intercept = 0, color = "grey", size = 1) +
  labs(
    y = "Scaled Memory Slopes",
    x = "Scaled Hippocampus Slopes",
    color = "Distance to CR line"
  ) +
  theme_minimal() +
  guides(color = guide_colorbar(reverse = TRUE))

ggplot(random_df, aes(y = y, x = x, color = (dist_to_double_cr))) +
  geom_point(size = 2) +
  scale_color_gradientn(
    colors = custom_colors,
    values = scales::rescale(c(-1, -0.77, -0.55, -0.33, -0.11, 0.11, 0.33, 0.55, 0.77, 1))
  ) +
  geom_abline(slope = 1, intercept = 0, color = "grey", size = 1) + # Line y = x
  geom_abline(slope = 0, intercept = 0, color = "grey", size = 1) +
  geom_abline(slope = 10000, intercept = 0, color = "grey", size = 1) +
  labs(
    y = "Scaled Memory Slopes",
    x = "Scaled Hippocampus Slopes",
    color = "Distance to CR point / line"
  ) +
  theme_minimal() +
  guides(color = guide_colorbar(reverse = TRUE))

summary(random_df$dist_to_double_cr)
summary(random_df$dist_to_double_bm)
```

Create visualization of the main data over time
```{r}
# Try with clean cohorts
long_emhc_data <- emhc_data %>%
  pivot_longer(
    cols = matches("^memory\\.\\d$|^age\\.\\d$|^adj_HIP_total\\.\\d$|^HIP_total\\.\\d$|dmn\\.\\d$|ec\\.\\d$"),
    names_to = c(".value", "timepoint"),
    names_pattern = "(.*)(\\d$)"
  )

long_emhc_data <- long_emhc_data %>%
  rename(
    age = "age.",
    dmn = "dmn.",
    ec_fc = "ec.",
    adj_HIP_total = "adj_HIP_total.",
    HIP_total = "HIP_total.",
    memory = "memory."
  )

# Convert 'cohort' and 'timepoint' to factors
long_emhc_data$cohort <- as.factor(long_emhc_data$cohort)
long_emhc_data$timepoint <- factor(long_emhc_data$timepoint, levels = unique(long_emhc_data$timepoint))

color_palette <- c("indianred2", "#86db49", "steelblue2", "#F7CA18")

# Create the plot age v memory
ggplot(long_emhc_data, aes(x = age, y = memory, color = cohort, group = id)) +
  geom_line(size = 0.4) +
  geom_point(size = 0.6) +
  geom_smooth(method = "lm", color = "grey", aes(group = 1)) +
  scale_color_manual(values = color_palette) +
  labs(x = "Age", y = "Memory Score", color = "cohort") +
  theme_minimal()

# Create the plot age v HC
ggplot(long_emhc_data, aes(x = age, y = adj_HIP_total, color = cohort, group = id)) +
  geom_line(size = 0.4) +
  geom_point(size = 0.6) +
  scale_color_manual(values = color_palette) +
  # geom_smooth(method = "lm", color = "grey", aes(group = 1)) +
  labs(x = "Age", y = "ICV Adjusted HC Volume", color = "cohort") +
  theme_minimal()

# Create the plot age v DMN
ggplot(data = long_emhc_data %>% filter(fc_obs > 1), aes(x = age, y = dmn, color = cohort, group = id)) +
  geom_line(size = 0.4) +
  geom_point(size = 0.6) +
  geom_smooth(method = "lm", color = "grey", aes(group = 1)) +
  scale_color_manual(values = color_palette) +
  labs(x = "Age", y = "DMN FC", color = "cohort") +
  theme_minimal()


# Create the plot age v ECN
ggplot(data = long_emhc_data %>% filter(fc_obs > 1), aes(x = age, y = ec_fc, color = cohort, group = id)) +
  geom_line(size = 0.4) +
  geom_point(size = 0.6) +
  geom_smooth(method = "lm", color = "grey", aes(group = 1)) +
  scale_color_manual(values = color_palette) +
  labs(x = "Age", y = "Executive Control Network FC", color = "cohort") +
  theme_minimal()
```
See whether linear or non-linear models are better, first for HC

```{r}
# Fit the GAM model
gamm_model_hc <- gam(adj_HIP_total ~ s(age, bs = "cs"), data = long_emhc_data)

# Fit the linear model
lm_model_hc <- lm(adj_HIP_total ~ age, data = long_emhc_data)

# Summary of the GAM model
summary(gamm_model_hc)

# Summary of the linear model
summary(lm_model_hc)

# Get model comparison statistics
aic_gamm <- AIC(gamm_model_hc)
aic_lm <- AIC(lm_model_hc)

bic_gamm <- BIC(gamm_model_hc)
bic_lm <- BIC(lm_model_hc)

# Output the AIC and BIC values
cat("AIC for GAM model:", aic_gamm, "\n")
cat("AIC for linear model:", aic_lm, "\n")

cat("BIC for GAM model:", bic_gamm, "\n")
cat("BIC for linear model:", bic_lm, "\n")

long_emhc_data$fitted_gamm_hc <- predict(gamm_model_hc, newdata = long_emhc_data)

# Create the plot age v HC
ggplot(long_emhc_data, aes(x = age, y = adj_HIP_total, color = cohort, group = id)) +
  geom_line(size = 0.4) +
  geom_point(size = 0.6) +
  scale_color_manual(values = color_palette) +
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"), aes(group = 1), color = "grey", se = TRUE) + # Add single GAM with confidence interval for all data
  labs(x = "Age", y = "ICV Adjusted HC Volume", color = "cohort") +
  theme_minimal()
```
Then see whether linear or non-linear models are better, second for memory

```{r}
# Fit the GAM model
gamm_model_mem <- gam(memory ~ s(age, bs = "cs"), data = long_emhc_data)

# Fit the linear model
lm_model_mem <- lm(memory ~ age, data = long_emhc_data)

# Summary of the GAM model
summary(gamm_model_mem)

# Summary of the linear model
summary(lm_model_mem)

# Get model comparison statistics
aic_gamm_mem <- AIC(gamm_model_mem)
aic_lm_mem <- AIC(lm_model_mem)

bic_gamm_mem <- BIC(gamm_model_mem)
bic_lm_mem <- BIC(lm_model_mem)

# Output the AIC and BIC values
cat("AIC for GAM model:", aic_gamm_mem, "\n")
cat("AIC for linear model:", aic_lm_mem, "\n")

cat("BIC for GAM model:", bic_gamm_mem, "\n")
cat("BIC for linear model:", bic_lm_mem, "\n")

long_emhc_data$fitted_gamm_mem <- predict(gamm_model_mem, newdata = long_emhc_data)

# Create the plot age v mem
ggplot(long_emhc_data, aes(x = age, y = memory, color = cohort)) +
  geom_line(aes(group = id), size = 0.4) + # Individual lines by id
  geom_point(size = 0.6) +
  scale_color_manual(values = color_palette) +
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"), color = "grey", se = TRUE) + # Single GAM with confidence interval for all data
  labs(x = "Age", y = "Memory", color = "cohort") +
  theme_minimal()
```

Now look at whether coliniarity could be and issue. Values greater than 10 would be an issue
```{r}

edu_cr_int <- lm(scale(memory_slopes) ~ scale(dist_to_double_cr) * scale(edu) + study, data = emhc_data)

# Extract the design matrix (model matrix)
model_matrix <- model.matrix(edu_cr_int)

# Remove the intercept column
model_matrix <- model_matrix[, -1]

# Function to calculate VIF
vif_calculator <- function(model_matrix) {
  vif_values <- numeric(ncol(model_matrix))
  names(vif_values) <- colnames(model_matrix)

  for (i in 1:ncol(model_matrix)) {
    predictor <- model_matrix[, i]
    other_predictors <- model_matrix[, -i]

    vif_model <- lm(predictor ~ other_predictors)
    r_squared <- summary(vif_model)$r.squared

    vif_values[i] <- 1 / (1 - r_squared)
  }

  return(vif_values)
}

# Calculate VIF values using the function
vif_values <- vif_calculator(model_matrix)
print(vif_values)
```

Now make an index to represent whether someone is more on a BM or CR path and how far along the path they are. Start by inversing BM and CR so that high values are good
```{r}
# Define function to reverse the CR / BM variables using their possible min and max values
reverse_values <- function(values) {
  max_value <- 3.414214
  min_value <- 0
  reversed <- (max_value + min_value) - values
  return(reversed)
}

# Reverse the bm and cr values
emhc_data$reverse_bm <- reverse_values(emhc_data$dist_to_double_bm)
emhc_data$reverse_cr <- reverse_values(emhc_data$dist_to_double_cr)

# Check that the output is ok
reversed <- emhc_data %>%
  select(id, reverse_bm, dist_to_double_bm, reverse_cr, dist_to_double_cr)

ggplot(emhc_data, aes(x = dist_to_double_bm, y = reverse_bm)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, col = "blue") +
  labs(
    title = "Scatter Plot of Original vs. Reversed Values",
    x = "Original Values", y = "Reversed Values"
  ) +
  geom_abline(slope = -1, intercept = 3.414214, color = "grey", size = 1) +
  ylim(0, 3.414214) +
  xlim(0, 3.414214)
```
Now take the reversed variables to make the index
```{r}
# Classify as closer to BM or CR and calculate the indices
emhc_data <- emhc_data %>%
  mutate(
    closer_to = ifelse(reverse_bm > reverse_cr, "BM", "CR"),
    index = ifelse(closer_to == "BM", (reverse_bm / reverse_cr) - 1, (-(reverse_cr / reverse_bm)) + 1) # need to -1 or +1 to make the axis center around 0
  )

# Check that everything looks ok
index_df <- emhc_data %>%
  select(id, reverse_cr, dist_to_double_cr, reverse_bm, dist_to_double_bm, closer_to, index)
```

Now plot the index with consideration of absolute amount of CR / BM
```{r}
# Create a variable to put on the y-axis that represents how much CR or BM someone has (eg if someone has more CR, this measures how much CR)

emhc_data <- emhc_data %>%
  mutate(
    cr_or_bm = ifelse(closer_to == "BM", abs(emhc_data$reverse_bm), abs(emhc_data$reverse_cr))
  )

emhc_data <- emhc_data %>%
  mutate(
    cr_and_bm = abs(emhc_data$reverse_bm) + abs(emhc_data$reverse_cr)
  )

emhc_data_idex <- emhc_data %>%
  select(id, cr_or_bm, reverse_bm, reverse_cr, index)

# Create breaks for the graph looks nice
breaks_values <- c(seq(-5, 5, by = 1), 0)
breaks_values <- sort(unique(breaks_values))

cr_bm_index <- ggplot(emhc_data, aes(x = index, y = cr_or_bm, fill = closer_to)) +
  geom_point(aes(color = closer_to), shape = 21, size = 3, position = position_jitter(width = 0.01)) +
  scale_fill_manual(values = c("BM" = "lightblue", "CR" = "#FFAAAA")) +
  scale_color_manual(values = c("BM" = "#000000", "CR" = "#000000")) +
  scale_x_continuous(
    name = "Distance from Midline",
    breaks = breaks_values,
    labels = scales::label_number(accuracy = .1),
    expand = c(0, 0),
    limits = c(-2.2, 2.2) # Set x-axis limits explicitly
  ) +
  labs(
    title = "Cognitive Reserve / Brain Maintenance Index",
    y = "Absolute Value of CR and BM",
    fill = "Pathway",
    color = "Pathway"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    plot.background = element_rect(fill = "white", color = "white"), # Set background to white
    plot.margin = margin(t = 0.35, r = 0.35, b = 0.35, l = 0.35, unit = "cm"),
    axis.text.x = element_text(margin = margin(t = -5)),
    plot.title = element_text(hjust = 0.5)
  )

cr_bm_index

ggsave("/tsd/p274/data/durable/projects/p027-cr_bm/CR-BM Index Plot.jpeg", plot = cr_bm_index, width = 10, height = 4, dpi = 400, units = "in")

# Make the same plot but filter out the extremes to see the middle better
ggplot(emhc_data, aes(x = index, y = cr_and_bm, fill = closer_to)) +
  geom_point(aes(color = closer_to), shape = 21, size = 3, position = position_jitter(width = 0.01)) +
  scale_fill_manual(values = c("BM" = "lightblue", "CR" = "#FFAAAA")) +
  scale_color_manual(values = c("BM" = "#000000", "CR" = "#000000")) +
  scale_x_continuous(
    name = "Distance from Midline",
    breaks = breaks_values,
    labels = scales::label_number(accuracy = .1),
    expand = c(0, 0),
    limits = c(-1, 1) # Set x-axis limits explicitly
  ) +
  labs(
    title = "Cognitive Reserve / Brain Maintenance Index",
    y = "Absolute Value of CR and BM",
    fill = "Pathway",
    color = "Pathway"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(),
    axis.ticks.y = element_line(),
    panel.grid.major.y = element_line(),
    panel.grid.minor.y = element_blank(),
    legend.position = "right",
    plot.margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "cm"),
    axis.text.x = element_text(margin = margin(t = -5)),
    plot.title = element_text(hjust = 0.5)
  )
```
```{r}
# Create the density heatmap
heatmap_plot <- ggplot(emhc_data, aes(x = index, y = res_mem_slopes)) +
  # Add semi-transparent rectangles for CR and BM backgrounds
  annotate("rect", xmin = -0.3, xmax = 0, ymin = -Inf, ymax = Inf, fill = "#87A2FF", alpha = 0.4) +
  annotate("rect", xmin = 0, xmax = 0.3, ymin = -Inf, ymax = Inf, fill = "#E3A5C7", alpha = 0.55) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon", color = "white", alpha = 0.6) +
  scale_fill_viridis_c(option = "C") +
  # scale_fill_gradient(low = "white", high = "darkgrey") +
  labs(
    x = "Distance from Midline",
    y = "Memory Annual Change",
    fill = "Density Level",
  ) +
  theme_minimal() +
  theme(
    axis.text = element_text(),
    panel.grid.minor = element_blank(),
    legend.position = "right"
  ) +
  coord_cartesian(
    xlim = c(-0.25, 0.25),
    ylim = c(-0.35, 0.3)
  ) +
  annotate("text", x = -0.15, y = 0.28, label = "Cognitive Reserve", size = 5, color = "#3C3D37", hjust = 0.5) +
  annotate("text", x = 0.15, y = 0.28, label = "Brain Maintenance", size = 5, color = "#3C3D37", hjust = 0.5)


heatmap_plot
```


Now plot the index without a y-axis (without consideration of absolute CR / BM)
```{r}
breaks_values <- c(seq(-5, 5, by = 1), 0)
breaks_values <- sort(unique(breaks_values))

index_plot <- ggplot(emhc_data, aes(x = index, y = 0, fill = closer_to)) +
  geom_violin(trim = FALSE, scale = "width", width = 6, position = position_identity()) +
  geom_jitter(aes(color = closer_to), shape = 21, size = 2.5, width = 0, height = 1.3) + # Increased jitter width
  scale_fill_manual(values = c("BM" = "lightblue", "CR" = "#FFAAAA")) +
  scale_color_manual(values = c("BM" = "#000000", "CR" = "#000000")) + # Match point color to fill colors
  scale_x_continuous(
    name = "Distance from Midline",
    breaks = breaks_values,
    labels = scales::label_number(accuracy = .1),
    expand = c(0, 0),
    limits = c(-2.2, 2.2) # Set x-axis limits explicitly
  ) +
  labs(
    title = "Cognitive Reserve / Brain Maintenance Index",
    fill = "Pathway",
    y = "",
    color = "Pathway"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    plot.background = element_rect(fill = "white", color = "white"), # Set background to white
    plot.margin = margin(t = 0.35, r = 0.35, b = 0.35, l = , unit = "cm"),
    axis.text.x = element_text(margin = margin(t = -5)),
    plot.title = element_text(hjust = 0.5)
  )

index_plot

ggsave("/tsd/p274/data/durable/projects/p027-cr_bm/Index Plot.jpeg", plot = index_plot, width = 10, height = 4, dpi = 400, units = "in")

# Make the same plot but filter out the extremes to see the middle clearer
ggplot(emhc_data, aes(x = index, y = 0, fill = closer_to)) +
  geom_violin(trim = FALSE, scale = "width", width = 6, position = position_identity()) +
  geom_jitter(aes(color = closer_to), shape = 21, size = 2.5, width = 0, height = 1.3) + # Increased jitter width
  scale_fill_manual(values = c("BM" = "lightblue", "CR" = "#FFAAAA")) +
  scale_color_manual(values = c("BM" = "#000000", "CR" = "#000000")) + # Match point color to fill colors
  scale_x_continuous(
    name = "Distance from Midline",
    breaks = breaks_values,
    labels = scales::label_number(accuracy = .1),
    expand = c(0, 0),
    limits = c(-1, 1) # Set x-axis limits explicitly
  ) +
  labs(
    title = "Cognitive Reserve / Brain Maintenance Index",
    fill = "Pathway",
    y = "",
    color = "Pathway"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    plot.background = element_rect(fill = "white", color = "white"), # Set background to white
    plot.margin = margin(t = 0.35, r = 0.35, b = 0.35, l = 0.35, unit = "cm"),
    axis.text.x = element_text(margin = margin(t = -5)),
    plot.title = element_text(hjust = 0.5)
  )
```

Look at the new index variable in terms of the colorful BM / CR charts to see where people fall
```{r}
ggplot(emhc_data, aes(y = res_mem_slopes, x = res_hc_slopes, color = (closer_to))) +
  geom_point(size = 2) +
  geom_abline(slope = -(abs(max(emhc_data$res_mem_slopes))) / (abs(min(emhc_data$res_hc_slopes))), intercept = 0, color = "grey", size = 1) +
  geom_abline(
    slope = (abs(max(emhc_data$res_mem_slopes)) / abs(min(emhc_data$hc_slopes))),
    intercept = 0,
    color = "grey",
    size = 1
  ) +
  geom_abline(slope = 0, intercept = 0, color = "grey", size = 1) +
  geom_abline(slope = 10000, intercept = 0, color = "grey", size = 1) +
  labs(
    y = "Residuals of Memory Slopes",
    x = "Residuals of Hippocampus Slopes",
    color = "Pathway"
  ) +
  theme_minimal()

ggplot(emhc_data, aes(y = res_mem_slopes, x = res_hc_slopes, color = (cr_and_bm))) +
  geom_point(size = 2) +
  scale_color_gradientn(
    colors = custom_colors,
    # limits = c(2, 5),
    values = c(0, 1 / 3, 2 / 3, 1) # Values mapped to scale 0 to 3
  ) +
  geom_abline(
    slope = -(abs(max(emhc_data$res_mem_slopes))) / (abs(min(emhc_data$res_hc_slopes))),
    intercept = 0,
    color = "grey",
    size = 1
  ) +
  geom_abline(
    slope = (abs(max(emhc_data$res_mem_slopes)) / abs(min(emhc_data$hc_slopes))),
    intercept = 0,
    color = "grey",
    size = 1
  ) +
  geom_abline(slope = 0, intercept = 0, color = "grey", size = 1) +
  geom_abline(slope = 10000, intercept = 0, color = "grey", size = 1) +
  labs(
    y = "Memory Slopes",
    x = "Hippocampus Slopes",
    color = "Total Amount of CR + BM"
  ) +
  theme_minimal()

ggplot(emhc_data, aes(y = res_mem_slopes, x = res_hc_slopes, color = abs(index))) +
  geom_point(size = 2) +
  scale_color_gradientn(
    colors = custom_colors,
    limits = c(0, 0.7),
    values = c(0, 1 / 3, 2 / 3, 1) # Values mapped to scale 0 to 3
  ) +
  geom_abline(
    slope = -(abs(max(emhc_data$res_mem_slopes))) / (abs(min(emhc_data$res_hc_slopes))),
    intercept = 0,
    color = "grey",
    size = 1
  ) +
  geom_abline(
    slope = (abs(max(emhc_data$res_mem_slopes)) / abs(min(emhc_data$hc_slopes))),
    intercept = 0,
    color = "grey",
    size = 1
  ) +
  geom_abline(slope = 0, intercept = 0, color = "grey", size = 1) +
  geom_abline(slope = 10000, intercept = 0, color = "grey", size = 1) +
  labs(
    y = "Memory Slopes",
    x = "Hippocampus Slopes",
    color = "Distance to Midline"
  ) +
  theme_minimal()
```

Considering criticisms of the residual approach (Elman et al. Alzheimer’s Research & Therapy (2022)).
```{r}
cr_hc_mem <- lm(scale(memory_slopes) ~ scale(reverse_cr) * scale(hc_slopes) + study, data = emhc_data)
summary(cr_hc_mem)

ggplot(emhc_data, aes(y = res_mem_slopes, x = reverse_cr)) +
  geom_point() +
  geom_smooth(method = "lm", color = "red") +
  labs(
    y = "Memory Annual Change",
    x = "CR"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    plot.background = element_rect(fill = "white", color = "white"), # Set background to white
    plot.margin = margin(t = 0.35, r = 0.5, b = 0.35, l = , unit = "cm"),
    axis.text.x = element_text(margin = margin(t = -5)),
    plot.title = element_text(hjust = 0.5)
  )

correlation_cr_bl <- cor(emhc_data$reverse_cr, emhc_data$res_mem_bl, use = "complete.obs")
print(correlation_cr_bl)
correlation_cr <- cor(emhc_data$reverse_cr, emhc_data$res_mem_slopes, use = "complete.obs")
print(correlation_cr)

ggplot(emhc_data, aes(y = res_mem_slopes, x = reverse_bm)) +
  geom_point() +
  geom_smooth(method = "lm", color = "red") +
  labs(
    y = "Memory Annual Change",
    x = "BM"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    plot.background = element_rect(fill = "white", color = "white"), # Set background to white
    plot.margin = margin(t = 0.35, r = 0.5, b = 0.35, l = , unit = "cm"),
    axis.text.x = element_text(margin = margin(t = -5)),
    plot.title = element_text(hjust = 0.5)
  )

correlation_bm_bl <- cor(emhc_data$reverse_bm, emhc_data$res_mem_bl, use = "complete.obs")
print(correlation_bm_bl)
correlation_bm <- cor(emhc_data$reverse_bm, emhc_data$res_mem_slopes, use = "complete.obs")
print(correlation_bm)
```
Create the standard CR residual variable to compare with our CR variable 

In summary, I get the same results for education and FC change (that it is not significantly associated with education or with FC change).	I get different results for the interaction between FC change & HC change (with our CR variable there is a significant interaction between FC change and HC change regressed on memory change but with the CR-residuals there are no significant interactions with any FC variables). 

```{r}
residual_model_cr <- lm(memory_slopes ~ hc_slopes + study, data = emhc_data)
emhc_data$cr_res_model <- residuals(residual_model_cr)

ggplot(emhc_data, aes(x = cr_res_model, y = dist_to_double_cr)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(
    x = "Residual CR Method",
    y = "Our CR Method"
  ) +
  theme_minimal()

correlation_cr_methods <- cor(emhc_data$dist_to_double_cr, emhc_data$cr_res_model, use = "complete.obs")
print(correlation_cr_methods)

# Now run the analysis with this variable
cr_res_edu <- lm(cr_res_model ~ edu, data = emhc_data)
summary(cr_res_edu)

ggplot(emhc_data, aes(x = edu, y = cr_res_model)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(
    x = "Education",
    y = "Residual Method Cognitive Reserve"
  ) +
  theme_minimal()

dist_cr_res_dmn_mem <- lm(scale(memory_slopes) ~ scale(cr_res_model) * scale(dmn_slopes) + study, data = emhc_data)
summary(dist_cr_res_dmn_mem)

dist_cr_res_mem_ec <- lm(scale(memory_slopes) ~ scale(cr_res_model) * scale(ec_slopes) + study, data = emhc_data)
summary(dist_cr_res_mem_ec)

dist_cr_res_dmn_mem <- lm(scale(dmn_slopes) ~ scale(cr_res_model) + study, data = emhc_data)
summary(dist_cr_res_dmn_mem)

dist_cr_res_mem_ec <- lm(scale(ec_slopes) ~ scale(cr_res_model) + study, data = emhc_data)
summary(dist_cr_res_mem_ec)
```

Now write the data frames as CSVs
```{r}
write.csv(emhc_data, file = "/tsd/p274/data/durable/projects/p027-cr_bm/Clean Data All Cohorts/Wide Format/Analysed data.csv")
```
